一、LockSupport
LockSupport是Java并发包中一个提供线程阻塞和唤醒的工具类，主要用于替代Object中的wait()、notify()等方法。
LockSupport提供了一个park()方法，可以使当前线程阻塞，而且不需要获取任何锁。此外，它还有一个unpark()方法，可以唤醒一个被阻塞的线程。
调用 LockSupport 的 park() 方法会阻塞当前线程，让其进入等待状态，因此，当一个线程调用 LockSupport.park() 方法时，如果没有其他
线程调用 LockSupport.unpark(thread) 方法对该线程进行唤醒，那么该线程就会一直阻塞下去，但是不会释放任何的锁或者资源，因此，这种阻塞
状态称为不可中断等待。
具体而言，park() 方法会阻塞当前线程，如果线程没有被中断，则会暂停线程执行，且该线程不会消耗 CPU 资源，因此 park() 方法并不会释放
任何锁或资源。而调用 unpark(Thread thread) 方法能够唤醒被阻塞的线程，并让其恢复执行。
需要注意的是，如果调用 unpark(Thread thread) 方法的时机比线程调用 park() 方法晚，也就是唤醒操作发生在被唤醒线程阻塞之后，那么
调用 park() 方法的线程不会阻塞，因为在此之前，调用了 unpark(thread) 方法对其设置了一个“许可（permit）”，因此 park() 方法直接
返回；如果唤醒操作发生在被唤醒线程阻塞之前，调用 park() 方法的线程会直接返回，且不会阻塞，因为它在 unpark(Thread thread) 方法
之前被赋予了许可（permit）。

总之，LockSupport 并不会释放已经获取到的锁或者资源，因此需要注意，应当在合适的时机调用 unpark(Thread thread) 来确保阻塞的线程
能够被及时唤醒。


二、ThreadLocal
ThreadLocal是Java编程语言的一个特性，它提供了一种创建变量局限于线程的方法。
每个线程都有一个ThreadLocalMap（ThreadLocal内部类），Map中元素的键为ThreadLocal，而值对应线程的变量副本。
这意味着每个线程都可以有自己的ThreadLocal变量实例，
对该变量的更改只在同一线程中可见。ThreadLocal变量通常用于多线程编程以存储线程特定的数据。例如，如果有一个处理多个任务的线程池，
则可以使用ThreadLocal变量来存储每个线程正在处理的当前任务的信息。
示例：
ThreadLocal<String> threadLocal = new ThreadLocal<String>();
threadLocal.set("Hello, world!");
String value = threadLocal.get();

回调引起的内存泄漏：
例如mq客户端给服务端写消息，服务端需要序列化、持久化等操作以及ACK，ACK操作相当于就是回调操作，需要在其他操作未执行前回调不会执行，
但是会锁住相关资源，如果写消息出现并发，那么相应的其他操作就会增多，回调锁住的资源就会变多，导致内存越来越少，长此以往会导致GC频繁
且释放不掉，此时就发生了内存泄漏。
解决办法：将回调操作抽象为单独的线程资源执行，每次记录参数并添加相应时间，需要回调执行时发信号让回调线程进行执行即可。
同理，归档操作也是类似。
内存泄漏时分析方法：保存内存现场，通过工具分析哪些对象调用多，调用关系等等，找出泄漏存在的真正地方。

"大幅降低MySQL服务主从延迟"指的是把复制mysql binlog所需的成本降成复制MDL语句的时间了吗？
然后"共享同一份存储层数据，大幅节约磁盘成本"，本地虽然不存了，云盘共享一份，那云盘不用备份吗？不是把成本从一个地方挪到另一个地方了吗？
而且这样改造之后，从库和主库连接的都是云盘的主，云盘的从就没用了吗？